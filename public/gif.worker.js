// gif.worker.js 0.2.0 - https://github.com/jnordberg/gif.js
(function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s })({ 1: [function (require, module, exports) { var NeuQuant = require("./neuquant"); var LZWEncoder = require("./LZWEncoder"); function ByteArray() { this.page = -1; this.pages = []; this.newPage() } ByteArray.pageSize = 4096; ByteArray.prototype.newPage = function () { this.pages[++this.page] = new Uint8Array(ByteArray.pageSize); this.cursor = 0 }; ByteArray.prototype.getData = function () { var length = this.pages.length * ByteArray.pageSize - (ByteArray.pageSize - this.cursor); var data = new Uint8Array(length); var offset = 0; for (var i = 0; i < this.pages.length; i++) { if (i === this.pages.length - 1) { data.set(this.pages[i].subarray(0, this.cursor), offset) } else { data.set(this.pages[i], offset) } offset += ByteArray.pageSize } return data }; ByteArray.prototype.writeByte = function (val) { if (this.cursor >= ByteArray.pageSize) this.newPage(); this.pages[this.page][this.cursor++] = val }; ByteArray.prototype.writeUTFBytes = function (string) { for (var i = 0, l = string.length; i < l; i++) { this.writeByte(string.charCodeAt(i)) } }; ByteArray.prototype.writeBytes = function (array, offset, length) { for (var i = 0, l = length || array.length, start = offset || 0; i < l; i++) { this.writeByte(array[i + start]) } }; function GIFEncoder(width, height) { this.width = ~~width; this.height = ~~height; this.transparent = null; this.transIndex = 0; this.repeat = -1; this.delay = 0; this.image = null; this.pixels = null; this.indexedPixels = null; this.colorDepth = null; this.colorTab = null; this.usedEntry = new Array; this.palSize = 7; this.dispose = -1; this.firstFrame = true; this.sample = 10; this.dither = false; this.globalPalette = false; this.out = new ByteArray } GIFEncoder.prototype.setDelay = function (milliseconds) { this.delay = Math.round(milliseconds / 10) }; GIFEncoder.prototype.setFrameRate = function (fps) { this.delay = Math.round(100 / fps) }; GIFEncoder.prototype.setDispose = function (disposalCode) { if (disposalCode >= 0) this.dispose = disposalCode }; GIFEncoder.prototype.setRepeat = function (repeat) { this.repeat = repeat }; GIFEncoder.prototype.setTransparent = function (color) { this.transparent = color }; GIFEncoder.prototype.addFrame = function (imageData) { this.image = imageData; this.getImagePixels(); this.analyzePixels(); if (this.globalPalette === true) this.analyzePixels(); if (this.firstFrame) { this.writeLSD(); this.writePalette(); if (this.repeat >= 0) { this.writeNetscapeExt() } } this.writeGraphicCtrlExt(); this.writeImageDesc(); if (!this.firstFrame && !this.globalPalette) this.writePalette(); this.writePixels(); this.firstFrame = false }; GIFEncoder.prototype.finish = function () { this.out.writeByte(59) }; GIFEncoder.prototype.setQuality = function (quality) { if (quality < 1) quality = 1; this.sample = quality }; GIFEncoder.prototype.setDither = function (dither) { if (dither === true) dither = "FloydSteinberg"; this.dither = dither }; GIFEncoder.prototype.setGlobalPalette = function (palette) { this.globalPalette = palette }; GIFEncoder.prototype.getGlobalPalette = function () { return this.globalPalette && this.colorTab && this.colorTab.slice(0) }; GIFEncoder.prototype.writeHeader = function () { this.out.writeUTFBytes("GIF89a") }; GIFEncoder.prototype.analyzePixels = function () { if (!this.colorTab) { this.currentIndex = 0; var quantizer = new NeuQuant(this.pixels, this.sample); quantizer.buildColormap(); this.colorTab = quantizer.getColormap(); this.usedEntry = []; for (var i = 0; i < this.colorTab.length; i += 3) { this.usedEntry.push(true) } this.indexedPixels = quantizer.lookupRGB(this.pixels, this.dither, this.transparent) } this.pixels = null; this.colorDepth = 8; this.palSize = 7; if (this.transparent !== null) { this.transIndex = this.findClosest(this.transparent) } }; GIFEncoder.prototype.findClosest = function (c) { if (this.colorTab === null) return -1; var r = (c & 16711680) >> 16; var g = (c & 65280) >> 8; var b = c & 255; var minpos = 0; var dmin = 256 * 256 * 256; var len = this.colorTab.length; for (var i = 0; i < len; i += 3) { var index = i / 3; if (this.usedEntry[index] && (this.colorTab === false || !this.globalPalette)) continue; var dr = r - this.colorTab[i]; var dg = g - this.colorTab[i + 1]; var db = b - this.colorTab[i + 2]; var d = dr * dr + dg * dg + db * db; if (this.usedEntry[index] && (d < dmin)) { dmin = d; minpos = index } } return minpos }; GIFEncoder.prototype.getImagePixels = function () { var w = this.width; var h = this.height; this.pixels = new Uint8Array(w * h * 3); var data = this.image; var count = 0; for (var i = 0; i < h; i++) { for (var j = 0; j < w; j++) { var b = i * w * 4 + j * 4; this.pixels[count++] = data[b]; this.pixels[count++] = data[b + 1]; this.pixels[count++] = data[b + 2] } } }; GIFEncoder.prototype.writeGraphicCtrlExt = function () { this.out.writeByte(33); this.out.writeByte(249); this.out.writeByte(4); var transp, disp; if (this.transparent === null) { transp = 0; disp = 0 } else { transp = 1; disp = 2 } if (this.dispose >= 0) { disp = this.dispose & 7 } disp <<= 2; this.out.writeByte(0 | disp | 0 | transp); this.out.writeByte(this.delay & 255); this.out.writeByte(this.delay >> 8 & 255); this.out.writeByte(this.transIndex); this.out.writeByte(0) }; GIFEncoder.prototype.writeImageDesc = function () { this.out.writeByte(44); this.out.writeByte(0); this.out.writeByte(0); this.out.writeByte(0); this.out.writeByte(0); this.out.writeByte(this.width & 255); this.out.writeByte(this.width >> 8 & 255); this.out.writeByte(this.height & 255); this.out.writeByte(this.height >> 8 & 255); if (this.firstFrame || this.globalPalette) { this.out.writeByte(0) } else { this.out.writeByte(128 | 0 | 0 | 0 | this.palSize) } }; GIFEncoder.prototype.writeLSD = function () { this.out.writeUTFBytes("GIF89a"); this.out.writeByte(this.width & 255); this.out.writeByte(this.width >> 8 & 255); this.out.writeByte(this.height & 255); this.out.writeByte(this.height >> 8 & 255); this.out.writeByte(240 | 0 | 0 | this.palSize); this.out.writeByte(0); this.out.writeByte(0) }; GIFEncoder.prototype.writeNetscapeExt = function () { this.out.writeByte(33); this.out.writeByte(255); this.out.writeByte(11); this.out.writeUTFBytes("NETSCAPE2.0"); this.out.writeByte(3); this.out.writeByte(1); this.out.writeByte(this.repeat & 255); this.out.writeByte(this.repeat >> 8 & 255); this.out.writeByte(0) }; GIFEncoder.prototype.writePalette = function () { this.out.writeBytes(this.colorTab); var n = 768 - this.colorTab.length; for (var i = 0; i < n; i++)this.out.writeByte(0) }; GIFEncoder.prototype.writePixels = function () { var enc = new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth); enc.encode(this.out) }; GIFEncoder.prototype.stream = function () { return this.out }; module.exports = GIFEncoder }, { "./LZWEncoder": 2, "./neuquant": 3 }], 2: [function (require, module, exports) { var EOF = -1; var BITS = 12; var HSIZE = 5003; var masks = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535]; function LZWEncoder(width, height, pixels, colorDepth) { var initCodeSize = Math.max(2, colorDepth); var accum = new Uint8Array(256); var htab = new Int32Array(HSIZE); var codetab = new Int32Array(HSIZE); var cur_accum = 0; var cur_bits = 0; var Number_of_bits = 12; var n_bits = 0; var clear_flg = false; var g_init_bits; var ClearCode; var EOFCode; function flush_char(outs) { if (cur_accum > 0) { outs.writeByte(cur_accum); outs.writeBytes(accum, 0, cur_accum); cur_accum = 0 } } function char_out(c, outs) { accum[cur_accum++] = c; if (cur_accum >= 254) flush_char(outs) } function cl_block(outs) { cl_hash(HSIZE); free_ent = ClearCode + 2; clear_flg = true; output(ClearCode, outs) } function cl_hash(hsize) { for (var i = 0; i < hsize; ++i)htab[i] = -1 } function compress(init_bits, outs) { var fcode; var i; var c; var ent; var disp; var hsize_reg; var hshift; g_init_bits = init_bits; clear_flg = false; n_bits = g_init_bits; maxcode = MAXCODE(n_bits); ClearCode = 1 << init_bits - 1; EOFCode = ClearCode + 1; free_ent = ClearCode + 2; cur_accum = 0; ent = pixels[0]; hshift = 0; for (fcode = HSIZE; fcode < 65536; fcode *= 2)++hshift; hshift = 8 - hshift; hsize_reg = HSIZE; cl_hash(hsize_reg); output(ClearCode, outs); var outer_loop = function (i) { c = pixels[i]; fcode = (c << BITS) + ent; i = c << hshift ^ ent; if (htab[i] === fcode) { ent = codetab[i]; return } else if (htab[i] >= 0) { disp = hsize_reg - i; if (i === 0) disp = 1; do { if ((i -= disp) < 0) i += hsize_reg; if (htab[i] === fcode) { ent = codetab[i]; return } } while (htab[i] >= 0) } output(ent, outs); ent = c; if (free_ent < 1 << BITS) { codetab[i] = free_ent++; htab[i] = fcode } else { cl_block(outs) } }; for (i = 1; i < pixels.length; i++)outer_loop(i); output(ent, outs); output(EOFCode, outs) } function output(code, outs) { cur_bits &= masks[n_bits]; if (cur_bits > 0) cur_bits |= code << n_bits; else cur_bits = code; n_bits += Number_of_bits; while (n_bits >= 8) { char_out(cur_bits & 255, outs); cur_bits >>= 8; n_bits -= 8 } if (free_ent > maxcode || clear_flg) { if (clear_flg) { maxcode = MAXCODE(n_bits = g_init_bits); clear_flg = false } else { ++n_bits; if (n_bits == BITS) maxcode = 1 << BITS; else maxcode = MAXCODE(n_bits) } } if (code == EOFCode) { while (n_bits > 0) { char_out(cur_bits & 255, outs); cur_bits >>= 8; n_bits -= 8 } flush_char(outs) } } function MAXCODE(n_bits) { return (1 << n_bits) - 1 } this.encode = function (outs) { outs.writeByte(initCodeSize); Number_of_bits = initCodeSize + 1; compress(initCodeSize + 1, outs); outs.writeByte(0) } } module.exports = LZWEncoder }, {}], 3: [function (require, module, exports) { function NeuQuant(thepic, quality) { var netsize = 256; var maxnetpos = netsize - 1; var netbiasshift = 4; var ncycles = 100; var radbiasshift = 8; var radiusbias = 1 << radbiasshift; var radiusdec = 30; var alphabiasshift = 10; var alphadec = 10; var alpha = 1 << alphabiasshift; var radbias = radiusbias; var radpower = radbias >> radiusdec; var alpharadbshift = alphabiasshift + radbiasshift; var rad = netsize >> 3; var initrad = rad * radiusbias; var network = new Int32Array(netsize << 2); var netindex = new Int32Array(256); var bias = new Int32Array(netsize); var freq = new Int32Array(netsize); var radpower = new Int32Array(rad); var map = new Int32Array(netsize); var pixels = null; var samplefac = 0; this.buildColormap = function () { init(); learn(); unbiasnet(); inxbuild() }; this.getColormap = function () { var map = []; var index = []; for (var i = 0; i < netsize; i++)index[map[i]] = i; for (var i = 0; i < netsize; i++) { var k = index[i]; var j = k << 2; map.push(network[j]); map.push(network[j + 1]); map.push(network[j + 2]) } return map }; this.lookupRGB = function (pixels, dither, transparent) { var i, j, r, g, b, al, index, n; var len = pixels.length; var dest = new Uint8Array(len / 3); var lookup; if (dither === "FloydSteinberg") { lookup = lookupRGBFloydSteinberg } else { lookup = lookupRGBNormal } for (i = 0, n = 0; i < len; i += 3, n++) { r = pixels[i]; g = pixels[i + 1]; b = pixels[i + 2]; index = lookup(r, g, b, n); dest[n] = index } return dest }; function init() { var i, v; for (i = 0; i < netsize; i++) { v = i << netbiasshift; network[i << 2] = v; network[(i << 2) + 1] = v; network[(i << 2) + 2] = v; freq[i] = 1 << 16; bias[i] = 0 } samplefac = quality; for (i = 0; i < rad; i++)radpower[i] = i >> radiusdec } function unbiasnet() { for (var i = 0; i < netsize; i++) { network[i << 2] >>= netbiasshift; network[(i << 2) + 1] >>= netbiasshift; network[(i << 2) + 2] >>= netbiasshift; network[(i << 2) + 3] = i } } function altersingle(alpha, i, b, g, r) { network[i << 2] -= alpha * (network[i << 2] - b) / 1024; network[(i << 2) + 1] -= alpha * (network[(i << 2) + 1] - g) / 1024; network[(i << 2) + 2] -= alpha * (network[(i << 2) + 2] - r) / 1024 } function alterneigh(rad, i, b, g, r) { var j, k, lo, hi, a, m; var p = network; lo = i - rad; if (lo < -1) lo = -1; hi = i + rad; if (hi > netsize) hi = netsize; j = i + 1; k = i - 1; m = 1; while (j < hi || k > lo) { a = radpower[m++]; if (j < hi) { p[j << 2] -= a * (p[j << 2] - b) / 262144; p[(j << 2) + 1] -= a * (p[(j << 2) + 1] - g) / 262144; p[(j << 2) + 2] -= a * (p[(j << 2) + 2] - r) / 262144; j++ } if (k > lo) { p[k << 2] -= a * (p[k << 2] - b) / 262144; p[(k << 2) + 1] -= a * (p[(k << 2) + 1] - g) / 262144; p[(k << 2) + 2] -= a * (p[(k << 2) + 2] - r) / 262144; k-- } } } function learn() { var i, j, b, g, r; var step; var pix = 0; var lim = thepic.length; if (lim < 3 * samplefac) samplefac = 1; step = samplefac * 3; var delta = lim / step; var alpha = 1 << alphabiasshift; var radius = initrad; var rad = radius >> radbiasshift; if (rad <= 1) rad = 0; for (i = 0; i < rad; i++)radpower[i] = alpha * (((rad * radius) - i * radiusbias) / (rad * radius)) >> alpharadbshift; if (lim % 499 !== 0) step = 1497; else if (lim % 491 !== 0) step = 1473; else if (lim % 487 !== 0) step = 1461; else step = 1509; for (i = 0; i < lim;) { b = thepic[i] << netbiasshift; g = thepic[i + 1] << netbiasshift; r = thepic[i + 2] << netbiasshift; j = contest(b, g, r); altersingle(alpha, j, b, g, r); if (rad !== 0) alterneigh(rad, j, b, g, r); i += step; if (i >= lim) i -= lim; if (delta === 0) delta = 1; if (i % delta === 0) { alpha -= alpha / ncycles; radius -= radius / ncycles; rad = radius >> radbiasshift; if (rad <= 1) rad = 0; for (j = 0; j < rad; j++)radpower[j] = alpha * (((rad * radius) - j * radiusbias) / (rad * radius)) >> alpharadbshift } } } function contest(b, g, r) { var i, dist, a, biasdist, betafreq; var bestd = 1 << 30; var bestbiasd = bestd; var bestpos = -1; var bestbiaspos = bestpos; var n = network; var f = freq; var bi = bias; for (i = 0; i < netsize; i++) { dist = n[i << 2] - b; if (dist < 0) dist = -dist; a = n[(i << 2) + 1] - g; if (a < 0) a = -a; dist += a; a = n[(i << 2) + 2] - r; if (a < 0) a = -a; dist += a; if (dist < bestd) { bestd = dist; bestpos = i } biasdist = dist - (bi[i] >> (12)); if (biasdist < bestbiasd) { bestbiasd = biasdist; bestbiaspos = i } betafreq = f[i] >> 10; f[i] -= betafreq; bi[i] += betafreq << 10 } freq[bestpos] += 64; bias[bestpos] -= 65536; return bestbiaspos } function inxbuild() { var i, j, smallpos, smallval; var p = network; var q; var previouscol = 0; var startpos = 0; for (i = 0; i < netsize; i++) { p[i << 2] = p[i << 2] >> netbiasshift; p[(i << 2) + 1] = p[(i << 2) + 1] >> netbiasshift; p[(i << 2) + 2] = p[(i << 2) + 2] >> netbiasshift; p[(i << 2) + 3] = i } for (i = 0; i < netsize - 1; i++) { smallpos = i; smallval = p[(i << 2) + 1]; for (j = i + 1; j < netsize; j++) { if (p[(j << 2) + 1] < smallval) { smallpos = j; smallval = p[(j << 2) + 1] } } q = p[smallpos << 2]; p[smallpos << 2] = p[i << 2]; p[i << 2] = q; q = p[(smallpos << 2) + 1]; p[(smallpos << 2) + 1] = p[(i << 2) + 1]; p[(i << 2) + 1] = q; q = p[(smallpos << 2) + 2]; p[(smallpos << 2) + 2] = p[(i << 2) + 2]; p[(i << 2) + 2] = q; q = p[(smallpos << 2) + 3]; p[(smallpos << 2) + 3] = p[(i << 2) + 3]; p[(i << 2) + 3] = q; if (i != startpos) { p[previouscol << 2] = startpos; p[(previouscol << 2) + 1] = i - 1; p[(previouscol << 2) + 2] = startpos; p[(previouscol << 2) + 3] = i - 1; startpos = i } previouscol = i } p[previouscol << 2] = startpos; p[(previouscol << 2) + 1] = netsize - 1; p[(previouscol << 2) + 2] = startpos; p[(previouscol << 2) + 3] = netsize - 1; for (i = 0; i < netsize; i++) { map[p[(i << 2) + 3]] = i } } function lookupRGBNormal(r, g, b, pixelIndex) { var i, j, dist, a, bestd; var p = network; bestd = 1e3; var best = -1; var idx = netindex[g]; var pred = idx >> 2; var start = p[pred]; var end = p[pred + 1]; for (i = start; i <= end; i++) { dist = p[i << 2] - b; if (dist < 0) dist = -dist; a = p[(i << 2) + 1] - g; if (a < 0) a = -a; dist += a; a = p[(i << 2) + 2] - r; if (a < 0) a = -a; dist += a; if (dist < bestd) { bestd = dist; best = p[(i << 2) + 3] } } return best } function lookupRGBFloydSteinberg(r, g, b, pixelIndex) { var index = lookupRGBNormal(r, g, b); return index } } module.exports = NeuQuant }, {}] }, {}, [1]);
